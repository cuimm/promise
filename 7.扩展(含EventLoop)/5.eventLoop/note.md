## 浏览器的事件环  (代码的执行顺序)

- js的"主线程"是单线程的

## 进程的概念
- 计算机在调度任务时是以进程为单位的，也是分配任务的最小单位
- 浏览器是多进程的（每一个页卡都是一个进程）
- 浏览器有一个主进程 用户的界面
- 每个页卡里都有一个渲染进程（浏览器内核）
- 处理请求 网络进程
- 绘图绘制 GPU渲染进程
- 其他的 浏览器的插件

> 渲染进程 (包含多个线程的)  最关心的

- ui渲染线程
- js引擎 执行js的（ui 和 js 是互斥的  共用同一个线程）
- 事件线程 click  定时器 setTimeout  ajax 也是一个独立的线程
- 单独的调度线程 处理事件 处理定时器到时间 ajax成功了  （事件触发线程 EventLoop）


- 常见的方法  “异步的”  方法分为两类 宏任务 （宿主环境提供的异步方法 都是宏任务）  微任务 （语言标准提供的 promise.then肯定不是定时器  mutationObserver）

## js的执行顺序
* 默认代码从上到下执行，执行环境通过script来执行，这是一个宏任务；
* 在代码执行的过程中，调用的定时器、promise、click事件等异步方法不会立即执行，需要等待当前代码全部执行完毕；
* 给异步方法划分队列，分别存放到微任务队列和宏任务队列中，其中，微任务是立即存放，宏任务是定时器时间到了或者click等事件发生了的时候才会放入
* script执行完毕后，会先清空微任务队列中所有的微任务。PS：有时候微任务不执行，那我们可以在自己添加一个宏任务，因为宏任务执行完毕之后，必须清空微任务。
* 执行完毕后，会渲染页面：ui渲染（不是每次都会调用，是根据浏览器的优化机制来渲染的，比如设置背景色，同一时间设置多次背景色，并不是每次都渲染，而是会缓存一下，根据浏览器的机制去渲染）
* 再去宏任务队列中看有没有到达时间的，取出其中一个执行
* 执行完毕后，按照上述步骤不停的循环执行

## Node中也有自己的事件环机制

> 浏览器和node事件环的执行结果 在node10版本之后就一致了，执行的方式不一样



> 注：Promise的executor是一个同步函数，即非异步，立即执行的一个函数，因此他应该是和当前的任务一起执行的。
> 而Promise的链式调用then，每次都会在内部生成一个新的Promise，然后执行then，在执行的过程中不断向微任务(microtask)推入新的函数，因此直至微任务(microtask)的队列清空后才会执行下一波的macrotask。


